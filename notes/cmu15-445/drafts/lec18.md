# 乐观并发控制：时间戳排序（TO）与乐观并发控制（OCC）

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [时间戳排序 (Timestamp Ordering, T/O)](#时间戳排序-timestamp-ordering-to)
  - [时间戳的源泉](#时间戳的源泉)
  - [基本时间戳排序协议 (Basic T/O)](#基本时间戳排序协议-basic-to)
    - [读操作规则](#读操作规则)
    - [写操作规则](#写操作规则)
  - [优化：托马斯写入规则 (Thomas Write Rule)](#优化托马斯写入规则-thomas-write-rule)
  - [Basic T/O 的挑战](#basic-to-的挑战)
- [乐观并发控制 (OCC)：终极的乐观主义者](#乐观并发控制-occ终极的乐观主义者)
- [OCC 的适用场景与瓶颈](#occ-的适用场景与瓶颈)
- [寻求平衡：分区时间戳排序 (Partition-based T/O)](#寻求平衡分区时间戳排序-partition-based-to)
  - [分区 T/O 的优势与挑战](#分区-to-的优势与挑战)
- [所有协议的共同难题：幻读 (The Phantom Problem)](#所有协议的共同难题幻读-the-phantom-problem)
- [结论：没有银弹，只有取舍](#结论没有银弹只有取舍)

<!-- /code_chunk_output -->

在数据库系统的世界里，ACID 中的“I”——隔离性（Isolation）是确保多用户环境下数据一致性的基石。为了实现隔离性，数据库管理系统（DBMS）必须采用并发控制协议（Concurrency Control Protocol）。其中， **两阶段锁定（Two-Phase Locking, 2PL）** 作为一种 **悲观** 策略，是我们最先接触也是最经典的协议之一。它如同一个谨小慎微的管家，假设事务之间总是会发生冲突，因此在任何操作前都要求先获取锁，即“先请求许可”。

然而，在许多真实世界的场景中，事务间的直接冲突并非那么频繁。悲观锁的开销——锁的获取、等待、释放以及潜在的死锁——可能会成为性能瓶颈。因此，数据库研究者们提出了另一类 **乐观** 的并发控制思想，它们更像是“先斩后奏，出了问题再处理”。

本文将深入探讨两种主流的乐观并发控制协议： **时间戳排序（Timestamp Ordering, T/O）** 和 **乐观并发控制（Optimistic Concurrency Control, OCC）** ，并介绍其衍生和面临的共同挑战。

### 时间戳排序 (Timestamp Ordering, T/O)

时间戳排序协议的核心思想极其优雅： **如果能为每个事务预先分配一个全局唯一且递增的时间戳，那么我们就可以强制所有事务的执行效果等同于按照时间戳顺序的串行执行** 。

换言之，如果事务 $T_i$ 的时间戳小于事务 $T_j$（即 $TS(T_i) < TS(T_j)$），那么无论它们在物理上如何交错执行，最终数据库的状态必须等同于 $T_i$ 在 $T_j$ 之前完整执行的效果。

#### 时间戳的源泉

为了实现这一目标，时间戳必须具备两个关键特性：**唯一性** 和 **单调递增性** 。DBMS 通常采用以下几种方式生成时间戳：

1.  **系统时钟 (System Clock)**：直接使用机器的物理时钟。这种方式简单直观，但在分布式系统中面临时钟同步的难题，且可能因夏令时等因素导致时钟回拨，破坏单调性。
2.  **逻辑计数器 (Logical Counter)** ：在内存中维护一个原子递增的计数器。它速度极快且无锁，能完美保证唯一性和单调性。但缺点是可能存在回卷（wrap-around）问题，虽然在64位系统上这几乎不可能发生。
3.  **混合方法 (Hybrid)** ：结合物理时钟和逻辑计数器。例如，将时间戳的高位赋予物理时间，低位赋予一个在该物理时间单位内递增的逻辑计数器。这是目前最主流和稳健的实现方式。

#### 基本时间戳排序协议 (Basic T/O)

在 Basic T/O 协议中，我们不再需要锁，而是为数据库中的每个数据对象（例如，一个元组）附加上一些元数据：

* **读取时间戳 (Read Timestamp, R-TS)** ：记录了成功读取该对象的、所有事务中 **最大** 的时间戳。
* **写入时间戳 (Write Timestamp, W-TS)** ：记录了成功写入该对象的事务的时间戳。

事务 $T_i$ 在执行读写操作时，将遵循以下规则：

##### 读操作规则

当 $T_i$ 尝试读取数据对象 $X$ 时：

1. **检查是否读取了“未来”的数据**
    * 如果 $TS(T_i) < W\text{-}TS(X)$，这意味着一个时间戳比 $T_i$ 更“新”的事务已经写入了 $X$。根据时间戳顺序，$T_i$ 本应读取一个更早版本的值。既然这个“未来”的值已经存在，说明时间线已经被破坏。因此，系统必须 **中止 $T_i$** ，并通常为其分配一个新的、更大的时间戳后重启。
2.  **执行读取并更新元数据**
    * 如果 $TS(T_i) \ge W\text{-}TS(X)$，校验通过，$T_i$ 可以读取 $X$。
    * 同时，系统需要更新 $X$ 的读取时间戳：$R\text{-}TS(X) = \max(R\text{-}TS(X), TS(T_i))$。这样做是为了记录下“在 $TS(T_i)$ 这个时间点，有人读取过 $X$ 的这个版本”，以防止后续更“旧”的事务前来写入。

**如何保证可重复读？** 为了防止 $T_i$ 在一次事务中两次读取 $X$ 得到不同的值，Basic T/O 要求事务在自己的 **私有工作空间** 中维护数据的本地副本。首次读取后，后续的读操作都将访问这个本地副本，从而与全局数据库的状态隔离。

##### 写操作规则

当 $T_i$ 尝试写入数据对象 $X$ 时，检查会更加严格：

1.  **检查读写冲突 (Read-Write Conflict)** ：
    * 如果 $TS(T_i) < R\text{-}TS(X)$，这意味着一个更“新”的事务已经读取了 $X$ 的旧版本。如果 $T_i$ 此时写入，将使得那个新事务的读取操作失效（它本应读取 $T_i$ 写入的新值）。这违反了时间戳顺序，因此 **必须中止 $T_i$** 。
2.  **检查写写冲突 (Write-Write Conflict)** ：
    * 如果 $TS(T_i) < W\text{-}TS(X)$，这与读操作的检查逻辑相同。一个更“新”的事务已经写入了 $X$。$T_i$ 的写入是一个“过时”的写入。为了维护顺序，**必须中止 $T_i$** 。
3.  **执行写入并更新元数据** ：
    * 如果上述检查全部通过，$T_i$ 会在自己的私有工作空间中修改 $X$ 的本地副本，并将更新后的 $W\text{-}TS(X)$ 设为 $TS(T_i)$。这些修改将在事务提交时真正写入数据库。

#### 优化：托马斯写入规则 (Thomas Write Rule)

Basic T/O 的写操作规则有些过于严苛。特别是对于写写冲突（$TS(T_i) < W\text{-}TS(X)$），我们真的需要中止事务吗？

**托马斯写入规则** 指出：在这种情况下，$T_i$ 的写入实际上是一个 **过时的写入 (obsolete write)** 。因为一个更新的事务已经成功写入，所以 $T_i$ 的这次写入无论如何都会被覆盖。那么，我们干脆 **直接忽略这次写入操作** ，让事务继续执行即可，无需中止。这个聪明的优化允许了更多的调度能够成功，提高了并发度。

**注意** ：此规则仅适用于写写冲突。如果 $TS(T_i) < R\text{-}TS(X)$，事务仍然必须中止，因为我们无法忽略一个已经发生过的“错误读取”。

#### Basic T/O 的挑战

尽管设计精巧，Basic T/O 协议也存在一些显著缺点：
* **高昂的开销** ：为每个数据对象维护和更新时间戳，以及将数据拷贝到事务的私有工作空间，都会带来不小的性能开销。
* **长事务饥饿 (Starvation)** ：一个长时间运行的事务，其时间戳相对较早，很容易与后续的短事务发生冲突，导致它被反复中止和重启，难以完成。
* **可能产生不可恢复的调度 (Non-recoverable Schedules)** ：一个事务可能读取了另一个尚未提交事务写入的数据。如果前者先提交，而后者最终中止，数据库将陷入不一致状态，且无法通过简单的回滚恢复。

### 乐观并发控制 (OCC)：终极的乐观主义者

如果说 T/O 协议是在每一步都检查时间戳，那么 **乐观并发控制 (Optimistic Concurrency Control, OCC)** 则将这种乐观精神发挥到了极致。OCC 的核心假设是： **事务间的冲突是小概率事件** 。因此，它完全省去了操作过程中的任何检查，让事务自由地在“沙箱”中执行，直到准备提交时，才进行一次性的冲突总检查。

OCC 的事务生命周期分为三个阶段：

1.  **读阶段 (Read / Work Phase)** ：事务读取数据，并将所有 **写操作** 记录在自己的 **私有工作空间** 中。所有修改对其他事务都是不可见的。在此阶段，系统会记录下事务的 **读集 (Read Set)** 和 **写集 (Write Set)** 。
2.  **验证阶段 (Validation Phase)** ：当事务发起提交时，它进入此关键阶段。DBMS 会在此刻为该事务 **分配一个时间戳** 。然后，系统会验证该事务的读写集是否与 **近期已提交的** 或 **正在并发验证的** 其他事务存在冲突，从而保证可串行化。如果验证失败，事务将 **中止** ，其在读阶段所做的所有工作全部作废。
3.  **写阶段 (Write Phase)** ：如果验证成功，DBMS 将把事务在其私有工作空间中的所有修改 **原子性地** 应用到数据库中，使其对所有后续事务可见。

### OCC 的适用场景与瓶颈

OCC 在以下场景中表现极其出色：
* **读密集型工作负载** ：大部分事务是只读的，冲突概率自然很低。
* **事务访问不相交数据** ：事务倾向于操作数据库中完全不同的部分。

在这些情况下，OCC 几乎没有并发控制的开销，性能非常高。

然而，在高冲突的工作负载下，OCC 的性能会急剧下降：
* **大量工作被浪费** ：由于冲突检测被推迟到最后，一个事务可能执行了大量复杂操作后，才在验证阶段被告知需要中止，造成了巨大的计算资源浪费。
* **验证阶段的瓶颈** ：尽管逻辑上冲突可能不多，但验证阶段本身需要检查并发事务的读写集。这个过程通常需要在一个临界区内串行执行，以保证数据结构的一致性。在高并发下，保护这个临界区的 **闩锁 (Latch)** 可能会成为新的性能瓶颈。

### 寻求平衡：分区时间戳排序 (Partition-based T/O)

为了解决 OCC 验证阶段的瓶颈问题，同时避免 Basic T/O 的高昂开销，业界提出了一种巧妙的混合方案—— **分区时间戳排序** 。

其核心思想是将数据库 **水平分区 (Partitioning / Sharding)** ，每个分区由一个独立的线程负责，并遵循以下规则：

* **分区内串行执行** ：在单个分区内部，所有事务严格按照其时间戳顺序 **串行执行** 。因为是单线程处理，所以分区内不再需要任何锁或闩锁来进行并发控制。
* **跨区并行处理** ：不同的分区可以并行地处理各自的事务队列。
* **原地更新 (In-place Updates)** ：由于分区内执行是串行的，事务可以直接修改数据，而无需像 OCC 那样复制到私有工作空间，从而降低了开销。系统会维护一个撤销日志（Undo Log）以便在事务中止时回滚。

**执行流程** ：一个事务在开始时被分配时间戳，并声明它需要访问的所有分区。然后，它必须获取所有这些分区的“分区锁”。一旦获取成功，并且它在所有相关分区的等待队列中都拥有最小的时间戳，它就可以开始执行。

#### 分区 T/O 的优势与挑战

**优势** ：对于 **单分区事务** ，其性能无与伦比，几乎能以“裸金属”的速度运行，因为它消除了所有并发控制的开销。

**挑战** ：
* **多分区事务** 变得复杂且可能成为瓶颈。一个跨区事务会“锁定”多个分区，可能导致这些分区在等待该事务时处于闲置状态。
* 该方案高度依赖于 **预先知晓事务的访问模式** 。DBMS 必须在事务开始前就知道它将触及哪些分区。这对于通过 **存储过程 (Stored Procedures)** 执行的事务来说是可行的，但对于交互式、即席查询的事务则非常困难。

### 所有协议的共同难题：幻读 (The Phantom Problem)

无论是悲观的 2PL，还是乐观的 T/O 和 OCC，它们在处理一个棘手问题时都会遇到麻烦，那就是 **幻读** 。

幻读是指：当一个事务 $T_1$ 基于某个 **谓词条件** （如 `WHERE status = 'active'`）读取了一组数据后，另一个并发事务 $T_2$ 插入了一条或多条满足该条件的新数据并提交。之后，如果 $T_1$ 再次以相同的条件执行查询，它会发现结果集中多出了一些之前不存在的“幻影”行。

**为什么元组级别的并发控制无法解决幻读？** 因为你无法对一个“尚不存在”的数据加锁或设置时间戳。传统的并发控制机制只能作用于已存在的数据项。

解决幻读的常用方法有：

* **谓词锁定 (Predicate Locking)** ：对查询的 `WHERE` 条件本身加锁。这在理论上最完美，但因其实现复杂度和巨大开销，在商业系统中极为罕见。
* **索引锁定 (Index Locking)** ：一种实用的谓词锁近似方案。通过锁定索引中的相关范围或 **间隙 (Gap)** ，来阻止满足条件的新数据被插入。这是目前主流数据库解决幻读问题的标准方法。
* **分层锁定 (Hierarchical Locks)** ：通过请求一个更粗粒度的锁（如表锁）来阻止任何插入，但这会严重牺牲并发性。

### 结论：没有银弹，只有取舍

通过今天的探讨，我们深入了解了数据库并发控制的“乐观”派系：

* **时间戳排序 (T/O)** ：通过预先定义的时间顺序来保证可串行化。它是一种“主动预防”的乐观策略，在每次操作时都进行检查，但容易导致事务中止。
* **乐观并发控制 (OCC)** ：将冲突检查推迟到最后一刻，是“事后验证”的终极乐观策略。它在低冲突场景下性能极佳，但在高冲突时则因工作浪费而表现糟糕。
* **分区时间戳排序** ：一种结合了分区思想的混合策略，旨在为特定类型的工作负载（尤其是单分区事务）提供极致性能。

最终，并发控制协议的选择没有绝对的优劣之分，它是一个基于应用 **工作负载** 的复杂权衡。是选择 2PL 的稳健与可预测性，还是拥抱 OCC 在低冲突环境下的高效，亦或是采用分区 T/O 这样的特化方案，都取决于我们对数据访问模式的深刻理解。作为数据库开发者和使用者，掌握这些协议的内在机理，将使我们能更好地设计和优化我们的系统。
