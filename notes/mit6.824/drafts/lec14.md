# LEC 14: Optimistic Concurrency Control

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [NotebookLM 生成的双人播客](#notebooklm-生成的双人播客)
- [Gemini 2.5 Pro 生成的“FaRM：极端硬件与乐观并发控制 Optimistic Concurrency Control”](#gemini-25-pro-生成的farm极端硬件与乐观并发控制-optimistic-concurrency-control)
  - [FaRM 的性能秘诀（一）：榨干硬件潜力](#farm-的性能秘诀一榨干硬件潜力)
    - [非易失性内存 (NVRAM)](#非易失性内存-nvram)
    - [远程直接内存访问 (RDMA)](#远程直接内存访问-rdma)
  - [FaRM 的性能秘诀（二）：专为 RDMA 设计的软件](#farm-的性能秘诀二专为-rdma-设计的软件)
    - [系统架构与角色](#系统架构与角色)
    - [乐观并发控制 (OCC) 的核心思想](#乐观并发控制-occ-的核心思想)
    - [剖析 FaRM 的提交协议](#剖析-farm-的提交协议)
    - [解答一致性与并发的疑虑](#解答一致性与并发的疑虑)
  - [局限性与总结](#局限性与总结)

<!-- /code_chunk_output -->

## NotebookLM 生成的双人播客

https://notebooklm.google.com/notebook/e0437017-2edc-435f-9410-44288931239d/audio

微信链接： https://mp.weixin.qq.com/s/jAUnubzYdS6cPZtZSxzz5g

给我留下的较深的印象：
1. 这里提出的硬件（内存数据库）+直接写内存网卡（跳过 receiver CPU）我认为都离实际生产太远
2. 乐观锁就是先计算，再在提交前校验

## Gemini 2.5 Pro 生成的“FaRM：极端硬件与乐观并发控制 Optimistic Concurrency Control”

好的，我们已经学习了分布式系统中的一系列关键技术，从底层的 GFS、RPC，到核心的 Raft 一致性协议，再到像 Spanner 这样工业级的全球分布式数据库。上一课的 Spanner 向我们展示了如何通过 **悲观并发控制 (Pessimistic Concurrency Control)** （即 2PL 两阶段锁）和创新的 TrueTime API，在广域网上实现具有外部一致性的分布式事务。

今天，我们将探讨一个截然不同的思路。如果我们的目标不是跨越洲际，而是要榨干单个数据中心内的每一分性能，那系统设计会变成什么样？这就是本课的主角 **FaRM** ，它通过 **乐观并发控制 (Optimistic Concurrency Control)** 和对尖端硬件的极致运用，给出了一个惊人的答案。

请注意，FaRM 是一个研究原型，目前还没有已知的生产系统直接使用它。它的价值在于探索设计的可能性。像微软、Google 这样的公司之所以发表这类论文，一方面是为了吸引顶尖人才，展示公司前沿的智力挑战；另一方面，许多研究人员本身就有推动技术进步的学术使命感。

> 换句话说， FaRM 有些前提或者假设比较理想，不适合现有生产环境。

### FaRM 的性能秘诀（一）：榨干硬件潜力

FaRM 的高性能并非空穴来风，它建立在软硬件协同设计的基础上，首先是两种颠覆传统瓶颈的硬件技术。

#### 非易失性内存 (NVRAM)

传统数据库最大的瓶颈之一是磁盘 I/O。一次写入到磁盘需要耗费数毫秒，即使是高速的固态硬盘 (SSD) 也要上百微秒。相比之下，内存 (DRAM) 的写入只需要几百纳秒，速度快了成千上万倍。FaRM 的设计哲学就是：所有数据都必须放在内存里。

但这带来了持久性的问题：内存是易失的，一旦断电，数据就会丢失。FaRM 采用了一种巧妙且经济的方式来打造 **非易失性内存 (Non-Volatile RAM)** 。它没有使用昂贵的专用 NVDIMM 硬件，而是在每个机架上部署了带锂电池的 **不间断电源 (UPS)** 。

工作流程如下：
1.  正常运行时，所有数据写入都直接在内存中完成，速度极快。
2.  当外部电源中断时，硬件会通知软件，服务器立即切换到电池供电。
3.  FaRM 软件会暂停所有事务处理，利用电池提供的几分钟电量，将内存中的全部内容转储到 SSD 上进行持久化。
4.  当电力恢复后，系统会从 SSD 中将数据重新加载回内存，然后从断点处继续运行。

这个设计至关重要。如果没有电池和 NVRAM，FaRM 就必须为每个事务同步地写入 SSD，其性能将会一落千丈，因为一次 SSD 写入比 FaRM 的目标延迟高出太多。那能否用更便宜的机械硬盘 (HDD) 来代替 SSD 呢？理论上可以，但 HDD 的写入速度要慢得多，这意味着需要容量更大、成本也更高的电池来支撑更长的转储时间，经济上可能得不偿失。

使用电池来保证断电时的数据持久性这个想法并不新鲜，早在 90 年代初的 Harp 文件系统就用过类似的技术。不过，FaRM 这种机架级别的分布式 UPS 方案在通用系统中并不常见。

#### 远程直接内存访问 (RDMA)

第二个传统瓶颈在于网络，尤其是处理网络消息所带来的 CPU 开销。一次传统的 **远程过程调用 (Remote Procedure Call, RPC)** 流程相当繁琐：

```txt
  应用层 (App)                                   应用层 (App)
      |                                              ^
      v                                              |
  系统调用 (System Call)                       中断 (Interrupt)
  ------------- 内核空间 (Kernel Space) ------------------
      |                                              ^
      v                                              |
  Socket 缓冲区 -> TCP协议栈                      TCP协议栈 <- NIC 驱动
      |                                              ^
      v                                              |
  NIC 驱动  --------------------------------------->  NIC
```

这个过程涉及到昂贵的系统调用、内核与用户空间之间的数据拷贝以及中断处理，极大地消耗了 CPU 资源，使得服务器处理小消息的速率受到限制。

FaRM 则使用了支持 **远程直接内存访问 (Remote Direct Memory Access, RDMA)** 的特殊 **网卡 (Network Interface Card, NIC)** 。RDMA 允许一台机器上的应用程序直接读写另一台远程机器的内存，而完全不需要远程机器 CPU 的参与，这个过程被称为 **单边 RDMA (one-sided RDMA)** 。请求由 NIC 直接处理，这绕过了远程服务器的整个操作系统内核，几乎消除了所有传统 RPC 的 CPU 开销，让网络通信的速度真正接近硬件的极限。

### FaRM 的性能秘诀（二）：专为 RDMA 设计的软件

有了强大的硬件，还需要同样出色的软件来发挥其潜力。FaRM 的软件设计完全围绕着如何最高效地利用 RDMA 和 NVRAM 。

#### 系统架构与角色

FaRM 是一个分片、多副本的系统。数据被切分成多个 `region`，每个 `region` 都有一个主副本和多个备份副本，以实现容错。系统中有三种核心角色：

* **Primary (主副本)** ：每个数据分片有且仅有一个主副本，负责处理该分片所有的读写请求。
* **Backup (备份副本)** ：被动地接收来自协调者的更新日志，保持与主副本数据一致，用于故障恢复。
* **Configuration Manager (CM, 配置管理器)** ：一个借助 ZooKeeper 实现的高可用服务，负责维护集群的元数据，例如哪些机器存活、数据分片的副本分布在哪些机器上等。

#### 乐观并发控制 (OCC) 的核心思想

这是本节课的重中之重。FaRM 采用 **乐观并发控制 (Optimistic Concurrency Control, OCC)** 的核心原因，是为了最大化地利用单边 RDMA 读取的性能优势。

* **悲观锁** (如 Spanner 的 2PL)：在访问数据时首先加锁，确保独占。这种方式安全直接，但每次读取都需要服务器 CPU 的介入来检查和获取锁，无法利用单边 RDMA。
* **乐观锁** ：假定事务之间的冲突很少发生。事务执行时，自由地读取数据，并将所有写操作缓存在本地。直到最后提交时，才进入一个“验证”阶段，检查在此期间是否有其他事务修改了它读取过的数据。如果验证通过，则提交成功；如果检测到冲突，则事务中止并回滚。

FaRM 的四阶段提交协议正是为 RDMA 量身定制的 OCC 实现。

#### 剖析 FaRM 的提交协议

让我们一步步解析这个协议（对应论文中的 Figure 4）：

1.  **执行 (Execute)** ：作为事务协调者 (TC) 的客户端，使用快速的单边 RDMA 从主副本上读取所需的对象，无需加锁。它会记下所有读取对象的版本号，并将写操作缓存在本地。
2. **锁定 (LOCK)** ：当事务准备提交时，TC 会向所有被它 *写入* 的对象所在的主副本发送 `LOCK` 记录。这条记录通过 RDMA 直接写入主副本的日志中，包含了新值和原始版本号。主副本的 CPU 在轮询日志时发现这条记录，会使用一个原子操作（`compare-and-swap`）来检查对象的版本号是否匹配并且未被锁定。如果匹配，就设置锁定标记；否则，锁定失败，整个事务将中止。
3. **验证 (VALIDATE)** ：对于那些只被 *读取* 而未被写入的对象，TC 无需执行完整的加锁操作。它会进行一次更轻量的验证：通过单边 RDMA 再次读取这些对象的版本号。如果版本号发生了变化，或对象已被其他事务锁定，说明发生了冲突，事务同样会中止。这个优化大大减少了只读事务的开销。
4. **提交备份 (COMMIT-BACKUP)** ：当锁定和验证都成功后，TC 确信事务是有效的。为了保证容错，它会将包含所有新数据的 `COMMIT-BACKUP` 记录写入所有相关备份副本的日志中。TC 只需等待 NIC 返回的硬件 ACK，确认数据已安全存入备份副本的 NVRAM 即可，无需等待备份副本的 CPU 进行任何处理。
5. **提交主库 (COMMIT-PRIMARY)** ：一旦所有备份副本都确认收到日志，TC 会向主副本发送最终的 `COMMIT-PRIMARY` 记录。至此，事务被正式视为已提交。主副本在处理这条日志时，会应用写入、更新版本号并释放锁，使更改对其他事务可见。

最后，当事务在所有副本上都完成后，协调者会发起一个 **截断 (Truncate)** 操作，通知各副本可以安全地删除这条事务对应的日志条目了。截断会删除某个点之前的所有日志，以回收空间。

#### 解答一致性与并发的疑虑

* **执行期间读到不一致数据怎么办？** FaRM 确实允许在事务执行中看到可能不一致的状态（例如，另一个最终会中止的事务留下的中间结果）。但 FaRM 保证，任何看到这种不一致性的事务，在提交时都会因验证失败而被中止。因此，应用程序需要有足够的防御性，不能因为暂时的不一致而崩溃，要能坚持到最后的提交阶段，由 FaRM 来决定成败。

* **高并发修改同一对象会怎样？** OCC 在高冲突场景下表现不佳。如果大量事务同时修改同一个对象，大部分事务会在 `LOCK` 或 `VALIDATE` 阶段失败，然后不断中止和重试，导致系统吞吐量急剧下降。FaRM 的出色性能数据，很大程度上是因为其测试负载的冲突率较低。

* **`COMMIT-BACKUP` 期间会失败吗？** 会。如果某个备份副本因为硬件故障而没有响应，并且此时 TC 也崩溃了，那么在后续的恢复流程中，这个事务可能会被中止。

* **为什么论文图 7 中延迟会飙升？** 这标志着系统已达到其处理能力的饱和点。当客户端发送请求的速率超过了服务器的处理极限时，请求就会开始排队等待，这种等待时间反映为延迟的急剧增加。

### 局限性与总结

FaRM 虽然强大，但它并非终结所有妥协的“银弹”。它是在特定约束下取得极致性能的典范，其局限性也十分明显：

* **高冲突敏感** ：如前所述，不适用于写冲突频繁的应用场景。
* **内存限制** ：整个数据集必须能完全载入集群所有机器的内存中。
* **单数据中心** ：其设计严重依赖数据中心内部的低延迟网络，不适用于地理上分散的广域网场景。
* **开发复杂性** ：它的 API 是回调式的，使用起来比较笨拙。应用代码需要自行处理轮询和临时不一致等问题，对开发者要求较高。

**它适合小规模使用吗？** 完全不适合。如果你的需求只是每秒几千次事务，那么像 MySQL 这样成熟稳定的传统数据库是更简单、更明智的选择。只有当你需要支撑每秒数百万甚至上千万次事务的巨大负载时，FaRM 的设计和复杂性才显示出其价值。

**总结**

FaRM 是一篇里程碑式的论文。它向我们证明了，通过颠覆性的软硬件协同设计，我们可以在数据中心这个特定场景内，同时拥有 **严格可串行化** 的强一致性、基于多副本的 **高可用性** 以及无与伦比的 **高性能** 。它虽然是一个研究原型，但它所揭示的关于乐观并发控制、RDMA 和 NVRAM 的潜力，为未来高性能分布式系统的设计开辟了全新的视野。
