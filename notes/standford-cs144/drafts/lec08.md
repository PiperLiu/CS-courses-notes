# 网络安全关键概念与手段 TLS/HTTPS

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [奠定安全基石：网络安全的四大核心属性](#奠定安全基石网络安全的四大核心属性)
- [知己知彼：理解我们面临的威胁](#知己知彼理解我们面临的威胁)
  - [意外破坏 (Accidental Corruption)](#意外破坏-accidental-corruption)
  - [对抗性攻击 (Adversarial Attacks)](#对抗性攻击-adversarial-attacks)
    - [窃听 (Eavesdropping)](#窃听-eavesdropping)
    - [篡改 (Modification)](#篡改-modification)
    - [重放 (Replay)](#重放-replay)
    - [中间人攻击 (Man-in-the-Middle, MITM)](#中间人攻击-man-in-the-middle-mitm)
    - [拒绝服务攻击 (Denial of Service, DoS)](#拒绝服务攻击-denial-of-service-dos)
    - [劫持 (Hijacking)](#劫持-hijacking)
  - [元数据隐私 (Metadata Privacy)](#元数据隐私-metadata-privacy)
- [铸造坚盾：密码学的核心工具箱](#铸造坚盾密码学的核心工具箱)
  - [安全哈希算法 (Secure Hash Algorithm)](#安全哈希算法-secure-hash-algorithm)
  - [消息认证码 (Message Authentication Code, MAC)](#消息认证码-message-authentication-code-mac)
  - [对称加密 (Symmetric Encryption)](#对称加密-symmetric-encryption)
  - [公钥密码学 (Public-key Cryptography)](#公钥密码学-public-key-cryptography)
  - [密钥交换与前向保密](#密钥交换与前向保密)
- [信任的根基：证书与公钥基础设施](#信任的根基证书与公钥基础设施)
- [实战剖析：TLS/HTTPS 如何保护你的通信](#实战剖析tlshttps-如何保护你的通信)
- [安全之道：超越算法的设计哲学](#安全之道超越算法的设计哲学)

<!-- /code_chunk_output -->

在本文中，我们将从网络安全的四大核心属性出发，逐步深入探讨常见的威胁模型、强大的密码学工具箱、保障信任的证书体系，并最终通过解析 TLS/HTTPS 协议，将所有知识点串联起来。

### 奠定安全基石：网络安全的四大核心属性

任何一个安全系统的设计，都离不开四个基本目标，它们是评估系统安全性的基石。

* **机密性 (Confidentiality)** ：确保信息只被授权的实体访问和理解。通俗地说，就是“不该看的人看不懂”。即使攻击者窃听了你们的通信，他也无法解读其中真正的内容。实现机密性的主要技术是 **加密 (Encryption)** 。一个有趣的应用是机会性加密 (Opportunistic encryption)，它指的是即使通信双方身份未经严格认证，也进行加密，其主要目的是防止大规模、非针对性的网络监听。

* **完整性 (Integrity)** ：确保数据在传输或存储过程中没有被未经授权地篡改或损坏。也就是说，你收到的数据必须和你朋友发送的数据一模一样，一个比特都不能差。需要注意的是，加密本身只保证机密性，并不能防止攻击者修改密文。在很多场景下，完整性的优先级甚至高于机密性。

* **真实性 (Authenticity)** ：确认通信参与方的身份是其所声称的身份。简单来说，就是“确认和你聊天的是你以为的那个人”。真实性是建立安全通信的前提，你必须先确认对方的身份，然后才能放心地将机密信息发送给他。 **证书 (Certificate)** 是实现真实性的关键技术。

* **可用性 (Availability)** ：确保授权用户在需要时能够正常访问和使用网络服务与资源。这个属性主要用来对抗拒绝服务攻击等旨在让服务瘫痪的攻击。

### 知己知彼：理解我们面临的威胁

网络世界中的威胁多种多样，我们可以将其大致分为两类：意外破坏和蓄意的对抗性攻击。

#### 意外破坏 (Accidental Corruption)

这类威胁并非出于恶意，而是由硬件故障、软件 `bug`、信道噪声等原因导致的数据损坏。我们熟悉的 `IP` 头的校验和、`TCP`/`UDP` 的校验和以及以太网的帧校验序列 (Frame Check Sequence, FCS)，其主要目的就是检测这类意外错误。

#### 对抗性攻击 (Adversarial Attacks)

这是我们关注的重点，指攻击者主动发起的、旨在破坏系统安全属性的恶意行为。

##### 窃听 (Eavesdropping)

攻击者被动地监听网络流量以获取敏感信息。在早期的集线器 (Hub) 以太网或如今的 Wi-Fi 环境中，数据包以广播形式发送，窃听相对容易。在现代交换式网络中，攻击者可以通过 **MAC 地址泛洪攻击 (MAC Overflow Attack)** ，向交换机发送大量伪造源 `MAC` 地址的数据包，耗尽其 `MAC` 地址表容量，迫使交换机进入“广播模式”，从而监听到整个网络的流量。

##### 篡改 (Modification)

攻击者在数据传输过程中主动修改、插入或删除数据。例如，攻击者可以修改数据包的目标地址，或者篡改 `DNS` 响应，将用户引导至恶意网站。为了不被发现，攻击者通常会重新计算并修改数据包的校验和。对抗篡改的主要武器是 **安全哈希** 和 **消息认证码 (Message Authentication Code, MAC)** 。

##### 重放 (Replay)

攻击者截获一段合法的通信数据，然后在稍后的时间点重新发送它，以达到欺骗系统的目的。例如，截获一个转账请求并重复发送。防御重放攻击的一个有效方式是确保协议操作的 **幂等性 (Idempotence)** ，即重复执行同一操作不会产生额外的副作用，或者在协议中加入时间戳或一次性随机数 (Nonce)。

##### 中间人攻击 (Man-in-the-Middle, MITM)

这是最经典也最危险的攻击之一。攻击者将自己插入到两个通信方之间，对双方冒充对方的身份，从而能够窃听、篡改甚至完全控制双方的通信，而通信双方却毫不知情。

**ARP 欺骗 (ARP Spoofing)** 是局域网中实现 `MITM` 的常见手段。攻击者通过伪造 `ARP` 响应，让用户的流量错误地发送到攻击者的机器上，再由攻击者转发给真正的网关。

```txt
# 正常通信 (Normal Communication)
# User A 的流量直接发往 Gateway
[ User A ] ----> [ Gateway ] ----> [ Internet ]

# ARP 欺骗后的通信 (Communication after ARP Spoofing)
# User A 的流量先被 Attacker 截获，再由 Attacker 转发
[ User A ] ----> [ Attacker ] ----> [ Gateway ] ----> [ Internet ]
```

##### 拒绝服务攻击 (Denial of Service, DoS)

`DoS` 攻击及其分布式版本 `DDoS`，旨在通过消耗目标的网络带宽、计算资源或连接数，使其无法为正常用户提供服务。`DDoS` 攻击通常由一个控制端和大量被操控的“僵尸网络 (Botnet)”构成。攻击手段五花八门，遍布网络协议的各个层级：

**网络层**
* **Ping 泛洪 (Ping Flood)** ：用海量的 `ICMP Echo Request` 数据包淹没目标。
* **Smurf 攻击** ：将伪造成受害者 `IP` 的 `ICMP Echo Request` 发送到一个网络的广播地址，导致该网络所有设备都向受害者回复 `IC-MP Echo Reply`，形成流量放大效应。
* **IP 碎片泛洪 (IP Fragment Flooding)** ：发送大量 `IP` 碎片，但故意不发送最后一个碎片，迫使目标服务器为重组数据包而持续分配内存，最终耗尽资源。

**传输层**
* **SYN 泛洪 (SYN Flood)** ：利用 `TCP` 三次握手的缺陷，攻击者发送大量伪造源 `IP` 的 `SYN` 包，服务器为这些半开连接分配资源并等待 `ACK`，最终导致连接表被耗尽。

**应用层**
* **DNS 放大攻击 (DNS Amplification Attack)** ：攻击者伪造受害者 `IP` 向大量开放 `DNS` 解析器发送一个短请求，而 `DNS` 服务器则会向受害者返回一个非常大的响应，从而放大攻击流量。
* **SSL/TLS 握手攻击** ：`SSL/TLS` 握手过程中，服务器需要进行计算密集型的公钥解密操作。攻击者通过发起大量握手请求来耗尽服务器的 `CPU` 资源。

##### 劫持 (Hijacking)

**BGP 劫持 (BGP Hijacking)** ：`BGP` 是互联网的路由协议。攻击者所在的自治系统 (Autonomous System, AS) 可以恶意地向全球宣告一个不属于它的 `IP` 地址段归它所有，从而将原本流向这个 `IP` 段的流量“劫持”到自己的网络中。2008 年巴基斯坦电信意外劫持 YouTube 流量就是一次著名的真实案例。

**TCP 连接劫持 (TCP Connection Hijacking)** ：攻击者通过预测 `TCP` 序列号 (Sequence Number)，在两个已建立连接的通信方之间注入恶意数据，从而接管该 `TCP` 连接。

#### 元数据隐私 (Metadata Privacy)

即使通信内容被加密，数据包的 `IP` 头部信息（如源/目标地址、数据包大小、通信时间）依然是明文的。这些元数据同样可以暴露大量隐私信息。为了保护元数据，人们开发了 **洋葱路由 (Onion Routing)** 等匿名通信技术，其最著名的实现就是 **Tor** 。Tor 通过多层加密和随机中继节点来隐藏用户的真实 `IP` 地址和通信路径。

```txt
# Tor 的工作原理示意
# 每一层 "洋葱皮" 只有对应的中继节点能解开
User -> [ Enc(Node1, Enc(Node2, Enc(Node3, Data))) ] -> Node1
       Node1 -> [ Enc(Node2, Enc(Node3, Data)) ] -> Node2
              Node2 -> [ Enc(Node3, Data) ] -> Node3
                     Node3 -> [ Data ] -> Destination
```

### 铸造坚盾：密码学的核心工具箱

密码学 (Cryptography) 是网络安全的数学基础，它为我们提供了对抗上述威胁的强大武器。

#### 安全哈希算法 (Secure Hash Algorithm)

哈希函数能将任意长度的输入（消息）转换成一个固定长度的输出（哈希值或摘要）。一个安全的哈希函数应具备两个关键特性：

1.  **单向性 (One-way)** ：从哈希值反推出原始输入在计算上是不可行的。
2.  **抗碰撞性 (Collision-resistant)** ：找到两个不同的输入，使得它们的哈希值相同，在计算上是不可行的。

哈希的主要用途是验证 **完整性** 。`SHA-256` 和 `SHA-3` 是当前推荐使用的算法，而 `MD5` 和 `SHA-1` 已被证明存在严重安全缺陷，应避免使用。

#### 消息认证码 (Message Authentication Code, MAC)

`MAC` 也被称为 **带密钥的哈希 (keyed hash)** 。它结合了一个秘密密钥 `K` 和消息 `M` 来生成一个认证标签 (tag)。接收方使用相同的密钥和收到的消息重新计算标签，并与收到的标签对比。如果一致，就能证明消息在传输过程中 **未被篡改 (完整性)** ，并且该消息确实 **来自持有相同密钥的发送方 (真实性)** 。`HMAC` 是一种基于哈希函数构造 `MAC` 的标准方法。

一个重要的实践原则是 **先加密，再认证 (Encrypt-then-MAC)** ，即对加密后的密文计算 `MAC` 值。

#### 对称加密 (Symmetric Encryption)

对称加密使用同一个密钥进行加密和解密。它的优点是速度快，适合加密大量数据。

**一次性密码本 (One-Time Pad)** ：理论上最安全的加密方式。它使用一个与明文等长的、完全随机的密钥，与明文进行异或 (`XOR`) 操作。它的安全性无懈可击，但前提是密钥必须是真随机、只使用一次且安全地分发。这些严苛的条件使其在实践中几乎无法应用。 **密钥重用是其致命缺陷** ，如果用同一密钥加密两条不同消息 `m1` 和 `m2`，攻击者可以通过 `c1 XOR c2` 直接得到 `m1 XOR m2`，从而破解密文。

**流密码 (Stream Ciphers)** ：它模拟了一次性密码本，通过一个种子密钥生成一个足够长的伪随机密钥流，然后与明文进行异或。早期的 Wi-Fi 加密协议 `WEP` 就使用了流密码，但因其设计缺陷而很快被攻破。

**分组密码 (Block Ciphers)** ：它将明文分成固定大小的块（如 128 位），然后对每个块进行加密。 **AES (Advanced Encryption Standard)** 是目前最流行、最安全的分组密码标准。为了加密比单个分组更长的消息，需要配合不同的 **工作模式 (mode of operation)** 。

* **电子密码本模式 (Electronic Code Book, ECB)** ：这是最简单但也最不安全的模式。它独立地加密每个明文块。如果明文中存在重复的块，那么加密后的密文中也会出现重复的块，从而暴露了原始数据的模式。 **绝对不要使用 ECB 模式！**
* **密文分组链接模式 (Cipher Block Chaining, CBC)** ：为了解决 `ECB` 的问题，`CBC` 模式在加密当前明文块之前，会先将其与前一个密文块进行异或。这使得即使明文块相同，产生的密文块也不同，从而隐藏了数据模式。`CBC` 需要一个随机且不可预测的 **初始化向量 (Initialization Vector, IV)** 作为第一个块的“前一个密文块”。

#### 公钥密码学 (Public-key Cryptography)

公钥密码学，也称非对称加密，使用一对密钥：一个 **公钥 (public key)** 和一个 **私钥 (private key)** 。公钥可以公开分发，而私钥必须由所有者严格保密。

* **加密通信** ：任何人都可以用接收方的公钥加密信息，但只有持有对应私钥的接收方才能解密。这完美地解决了对称加密中密钥分发的难题。
* **数字签名 (Digital Signature)** ：发送方可以用自己的私钥对消息的哈希值进行“签名”，接收方可以用发送方的公钥来验证签名。如果验证通过，就能确认消息的 **完整性** 和 **真实性** （即消息确实由该私钥所有者发出且未被篡改）。

`RSA` 是最著名的公钥算法。相比对称加密，公钥加密的计算开销非常大。因此，在实践中，通常采用混合方案： **使用公钥加密来安全地协商一个临时的对称密钥，然后使用这个对称密钥进行高效的数据加密** 。

#### 密钥交换与前向保密

**Diffie-Hellman (迪菲-赫尔曼)** 密钥交换协议允许通信双方在一个完全公开的信道上，协商出一个只有他们两人知道的共享秘密，即使窃听者监视了所有交换过程也无法得知这个秘密。

一个极其重要的概念是 **前向保密 (Forward Secrecy)** 。它指的是，即使服务器的长期私钥在未来某个时间点被泄露，攻击者也无法用这个私钥解密过去被截获的通信数据。实现前向保密的关键在于每次会话都使用临时的、用后即焚的密钥（例如 `Ephemeral Diffie-Hellman`），而不是直接使用服务器的长期私KEY。

临时密钥并不“传输”私钥本身，而是双方各自产生临时密钥对并只交换临时公钥；通过（Ephemeral）Diffie–Hellman 的数学操作在双方本地各自算出相同的共享密钥。攻击者即便事后拿到长期私钥，也无法从握手中记录的公钥推算出当时的会话密钥（前提是离散对数问题不可解）。

**关键差别——RSA 密钥交换 vs. Ephemeral DH (DHE/ECDHE)**

* 在传统的 RSA 密钥交换（早期 TLS 配置）中，客户端生成 `pre-master` 并用服务器的 **长期公钥** 加密后发送。若攻击者事后获得服务器的长期私钥，就能解密录下的握手记录，从而恢复 `pre-master` 并解密过去会话 —— **没有前向保密** 。
* 在 **Ephemeral Diffie–Hellman (DHE/ECDHE)** 中，客户端和服务器各自生成一次性的（ephemeral）DH 私钥与对应公钥，只交换 **公钥** 。最终的会话密钥 = 基于双方私钥与对方公钥在本地计算得到的共享值（例如 $g^{ab}$），私钥从未离开各自主机，也不会被明文发送。即使攻击者后来拿到服务器长期私钥，**也无法由握手记录推出当时的 ephemeral 私钥或共享密钥** ，因此过去会话保持保密 —— **实现前向保密** 。

**数学/实现上的直观** ：双方交换的是 $A=g^a$ 和 $B=g^b$（公钥），客户端计算 $B^a=g^{ba}$，服务器计算 $A^b=g^{ab}$，两者相同。要从 $A$ 或 $B$ 推出 $a$ 或 $b$ 需要解决离散对数问题（被认为不可行）。

**但注意两点例外 / 限制：**

1. 如果实现或配置错误（例如服务器同时记录或泄露了 ephemeral 私钥，或使用非临时的 DH 参数），前向保密就失效。
2. 如果未来有算法/硬件（例如大规模量子计算机）能高效解决相应数学问题，那么现在记录的握手也可能被解密 —— 这是为什么加密算法和参数需要周期性更新的原因。

TLS 1.3 默认使用基于（椭圆）DH 的 ephemeral 密钥交换，天然优先前向保密；而 TLS 1.2 只有在使用 ECDHE/DHE 时才有前向保密，使用 RSA 密钥交换就没有。

### 信任的根基：证书与公钥基础设施

公钥密码学很棒，但它留下一个关键问题：我如何确定这个公钥真的属于 `Amazon`，而不是某个中间人攻击者伪造的？

答案是 **公钥基础设施 (Public Key Infrastructure, PKI)** 和 **数字证书 (Digital Certificate)** 。

* **证书** ：一个由权威机构颁发的数字文件，它将一个身份（如域名 `www.google.com`）和一个公钥绑定在一起。
* **证书颁发机构 (Certificate Authority, CA)** ：一个受信任的第三方，负责验证申请者的身份，并用自己的私钥为申请者的证书进行签名。
* **信任链 (Chain of Trust)** ：你的操作系统和浏览器预装了一批“根 `CA`”的证书。当你访问一个网站（如 `google.com`）时，它会出示自己的证书。这个证书可能是由一个“中间 `CA`”颁发的，而这个中间 `CA` 的证书又是由根 `CA` 颁发的。通过逐级验证签名，你的浏览器最终可以确认 `google.com` 的证书是可信的，从而建立起一条信任链。

为防止 `CA` 被攻破或滥用权力， **证书透明度日志 (Certificate Transparency Log)** 机制被提了出来。它要求所有 `CA` 公开记录其颁发的每一份证书，允许任何人监督，从而及时发现未经授权的证书。

### 实战剖析：TLS/HTTPS 如何保护你的通信

**TLS (Transport Layer Security)** ，即传输层安全协议，是 `HTTPS` 的核心。它位于 `TCP` 之上，应用层之下，为 `HTTP` 等应用层协议提供机密性、完整性和真实性保护。下面是 `TLS` 1.2 握手协议的简化流程：

1.  **Client Hello** ：客户端向服务器发送它支持的 `TLS` 版本、一个密码套件 (Cipher Suite) 列表和一个随机数 `random_c`。
2.  **Server Hello** ：服务器从列表中选择一个密码套件，返回自己的证书和一个随机数 `random_s`。
3.  **密钥交换** ：客户端验证服务器证书。验证通过后，生成一个 **预主密钥 (pre-master secret)** ，用服务器证书中的公钥加密后发送给服务器。
4.  **生成会话密钥** ：客户端和服务器现在都拥有了 `random_c`、`random_s` 和 `pre-master secret`。它们使用这三个随机源，通过一个伪随机函数 (PRF) 计算出完全相同的 **主密钥 (master secret)** ，并由主密钥进一步派生出会话所需的所有对称密钥（加密密钥、MAC 密钥等）。
5.  **Finished** ：双方各自发送一个 `Finished` 消息，该消息是之前所有握手消息的 `MAC` 值，并用刚刚生成的会话密钥加密。这可以验证整个握手过程没有被篡改。

握手完成后，双方就可以使用协商好的对称会话密钥来加密和认证应用数据了。现代的 `TLS` (如 `TLS` 1.3) 还会优先使用支持前向保密的密钥交换算法 (如 `ECDHE`)。

下面是 `TLS` 1.3 握手协议的流程：

1. **Client Hello** （客户端）：
* 包含支持的 TLS 版本集合、密码套件列表、`key_share`（客户端的 ephemeral 公钥，如 ECDHE 公钥）、`psk` / `early_data`（若尝试 0-RTT）、以及 ALPN 等扩展。
* 客户端计算并保存握手记录的 transcript（握手消息哈希）。
2. （可能） **HelloRetryRequest** （服务器）：如果服务器需要客户端使用其他曲线或密钥交换参数，会返回 HelloRetryRequest，客户端据此发送一个更新过 `ClientHello`（带新的 `key_share`）。
3. **ServerHello** （服务器）：选择版本、密码套件并返回自己的 `key_share`（服务器 ephemeral 公钥）。到这一步，双方都能基于各自的 ephemeral 私钥与对方公钥导出共享密钥（ECDHE 生成的共享值）。
4. **派生握手密钥（Handshake keys）** ：双方使用 HKDF 等机制基于共享值与早期 secret（若有 PSK）派生出“握手密钥”，用于对后续握手消息加密/认证。
5. **EncryptedExtensions、Certificate、CertificateVerify、Finished（服务器→客户端）** ：服务器在加密的握手通道上发送其证书（如果需要），并用 `CertificateVerify` 对证书内容进行签名，然后发送 `Finished`。这些消息已经由握手密钥加密/认证，从而防止中间人篡改握手后半程。
6. **客户端验证并响应** ：客户端验证证书链与 `CertificateVerify`，计算 transcript hash，验证服务器的 `Finished`，然后发送（加密的）`Finished` 给服务器。
7. **应用数据（Encrypted Application Data）** ：双方用由 master secret 派生出的应用密钥来加密后续的应用数据（HTTP 请求/响应）。
8. **会话恢复 / NewSessionTicket（可选，服务器在握手后发送）** ：服务器可在握手完成后发送 `NewSessionTicket`，客户端以后用它 + PSK 做会话恢复或 0-RTT 数据发送。

这里的 0-RTT（zero-Round-Trip-Time） 是 TLS 1.3 的一项特性，允许客户端在发出第一次网络包（ClientHello）时就把应用数据一起发出去，无需等待服务器完成完整握手。换句话说：客户端可以在“第 0 个往返”就发送数据，从而显著降低延迟（对首包请求很有用）。

HTTPS 基本流程就是这样：应用（HTTP）在 TLS 之上，TLS 在传输层（通常是 TCP）之上。常见 HTTPS 流程为：建立 TCP → 在该 TCP 上做 TLS 握手 → 握手完成后在加密通道上发送 HTTP。但也有现代变体（比如 QUIC/HTTP/3）把 TLS 与传输层更紧密地结合了。

传统 HTTPS（HTTP/1.1、常见 HTTP/2 实现）：

1. DNS 解析 → 2. 与服务器建立 **TCP** 连接（例如到 443 端口）。
2. 在那个 TCP 连接上进行 **TLS 握手** （协商协议版本、密码套件、完成密钥交换并建立加密通道）。
3. TLS 完成后， **HTTP** 请求/响应以加密形式在该通道上传输（HTTP 报文被 TLS 封装和保护）。
4. TLS 握手期间可以通过 **ALPN（Application-Layer Protocol Negotiation）** 协商使用 HTTP/2、HTTP/1.1 等。

**HTTP/3（QUIC）例外**

* QUIC 是基于 UDP 的新传输协议，它将运输层功能和 TLS 安全集成在同一个协议里。也就是说，QUIC 在握手过程中同时完成传输层建立和 TLS 安全协商（TLS 1.3 的握手被嵌入 QUIC），因此没有先 TCP 再 TLS 再 HTTP 的严格分层：是 UDP → QUIC（内含 TLS）→ HTTP/3。这样可以减少连接建立延迟和提升迁移/重连性能。

**其他补充**

* **TLS 会话恢复 / PSK** ：为了降低延迟，客户端可使用会话恢复或预共享密钥（PSK）来跳过完整握手，从而减少 RTT。TLS 1.3 在这方面更高效（0-RTT 有风险：早期数据在重放和部分安全属性上要谨慎）。
* TLS 本身不是专门为 HTTP 设计的，它可以保护多种应用层协议（SMTP、IMAP、数据库协议等），但 HTTPS 是其最常见的应用场景。

### 安全之道：超越算法的设计哲学

一些超越具体技术的高层次安全原则如下。

* **不要自己发明或实现加密算法 (Don't roll your own crypto)** ：密码学极其微妙，一个微小的实现错误都可能导致整个系统崩溃。永远优先使用经过公开、严格审查的、被广泛接受的标准库和实现。

* **保持加密敏捷性 (Crypto Agility)** ：在设计系统时，应使其能够方便地切换和升级加密算法。当某个算法被发现不再安全时，你可以迅速迁移到更强的替代方案。

* **培养安全思维 (Security Mindset)** ：始终以攻击者的视角来审视自己设计的系统。遵循 **纵深防御 (Defense in Depth)** 和 **最小权限原则 (Least Privilege)** ，假设任何组件都可能被攻破，并为此设计应对措施。

* **假定网络是不安全的 (Assume the network is insecure)** ：这是网络安全设计的黄金法则。永远不要信任底层的网络。你应该假设攻击者可以窃听、篡改、重放、劫持你的所有网络通信，并在此基础上构建你的安全协议。
